.program lcd_spi

.side_set 3 opt         ;side-set pin number is 3
.pio_version 0          ;pio version is at least 0(rp2040)
.fifo tx                ;TX FIFO is exclusive to 8 bytes
.out 1 left auto        ;out pin numbers is 1, msb first, auto pull enable

;Data/CMD select pin is gpio 8, and on side-set pin 0
;Chip Select pin is gpio 9, and on side-set pin 1
;spi clock pin is gpio 10, and on side-set pin 2
;spi mosi pin is gpio 11, and on out pin 0

;Note:
;   If the total number of bits of data in the data stage is a multiple of 32,
;   then after the transmission is completed, a 32-bit number must be sent again 
;   so that the program in the end label can be executed, 
;   and the state machine of the compilation returns to its initial state!!!!!

.wrap_target
start:
    out x, 24           side 0b010  ;clk->0,cs->disable,dc->cmd,msb 24-bit is 7
cmd_loop:
    out pins, 1         side 0b000  ;clk->0,cs->enable,dc->cmd
    jmp x-- cmd_loop    side 0b100  ;clk->1,cs->enable,dc->cmd
    out x, 32
    jmp !x start                    ;no bit, restart
data_loop:    
    out pins, 1         side 0b001  ;clk->0,cs->enable,dc->data
    jmp x-- data_loop   side 0b101  ;clk->1,cs->enable,dc->data
end:
    out null, 32                    ;abandon the remaining OSR
.wrap


% c-sdk {
// For optimal use of DMA bandwidth we would use an autopull threshold of 32,
// and Set the DMA bit width to 32.

#include "pico/binary_info.h"

// 16-bit pixel transmission format
typedef struct
{                       // msb
    uint16_t pixel_1;   // Pixel 1 in the lower half of the character
    uint16_t pixel_0;   // Pixel 0 in the upper half of the character
} __attribute__((packed)) pixel_t;

typedef union pixel_format_16pp_t
{
    pixel_t p;
    uint32_t u32;
} __attribute__((packed)) pixel_format_16pp_t;

static_assert(sizeof(pixel_format_16pp_t) == sizeof(uint32_t), "pixel_format_16pp_t size muts be 4-Byte!!!");

// if [no] use dma, used it
typedef struct
{
    uint8_t cmd;
    uint8_t cbits;  // must be 7
    uint16_t res;   // must be 0
} __attribute__((packed)) pio_lcd_cmd_t;

static_assert(sizeof(pio_lcd_cmd_t) == sizeof(uint32_t), "pio_lcd_cmd_t size muts be 4-Byte!!!");


typedef struct
{
    uint32_t dbits;
} __attribute__((packed)) pio_lcd_data_bits_t;

static_assert(sizeof(pio_lcd_data_bits_t) == sizeof(uint32_t), "pio_lcd_data_bits_t size muts be 4-Byte!!!");


/// @brief pio init
/// @param pio : PIO instance
/// @param SidePinBase : side-set pins base
/// @param OutPin : out pin
/// @param div : pio clock divide number
/// @return state machine number
static inline uint ullcd_program_init(PIO pio, uint SidePinBase, uint OutPin, float div)
{
#if 0
    // Make the DC pin available to picotool
    bi_decl(bi_1pin_with_name(SidePinBase, "LCD DC"));
    // Make the CS pin available to picotool
    bi_decl(bi_1pin_with_name(SidePinBase + 1, "LCD CS"));
    // Make the CLK pin available to picotool
    bi_decl(bi_1pin_with_name(SidePinBase + 2, "LCD CLK"));
    // Make the MOSI pin available to picotool
    bi_decl(bi_1pin_with_name(OutPin, "LCD MOSI"));    
#endif
    // get pio program offset
    uint pio_offset = pio_add_program(pio, &lcd_spi_program);
    // get idle state machine
    uint idle_sm = pio_claim_unused_sm(pio, true);
    // gpio switch to pio function
    pio_gpio_init(pio, SidePinBase + 0);    // cata/cmd select, [side-set pin 0]
    pio_gpio_init(pio, SidePinBase + 1);    // chip select,     [side-set pin 1]
    pio_gpio_init(pio, SidePinBase + 2);    // spi clock,       [side-set pin 2]
    pio_gpio_init(pio, OutPin);             // spi mosi,        [out pin]
    // output 0, SPI_CPOL_0, SPI_CPHA_0
    /* do something... */
    // Set pin direction, all output
    pio_sm_set_consecutive_pindirs(pio, idle_sm, SidePinBase + 0, 1, true);
    pio_sm_set_consecutive_pindirs(pio, idle_sm, SidePinBase + 1, 1, true);
    pio_sm_set_consecutive_pindirs(pio, idle_sm, SidePinBase + 2, 1, true);
    pio_sm_set_consecutive_pindirs(pio, idle_sm, OutPin, 1, true);
    // set state machine
    pio_sm_config c = lcd_spi_program_get_default_config(pio_offset);
    // set side-set pin base
    sm_config_set_sideset_pins(&c, SidePinBase);
    // set out pin
    sm_config_set_out_pins(&c, OutPin, 1);
    // set clock divide
    sm_config_set_clkdiv(&c, div);
    pio_sm_init(pio, idle_sm, pio_offset, &c);
    pio_sm_set_enabled(pio, idle_sm, true);
    // return used sm
    return idle_sm;
}


// Send data to Pio

// Making use of the narrow store replication behaviour on RP2040 to get the
// data left-justified (as we are using shift-to-left to get MSB-first serial)

/// @brief put a double-word(32-bit) to lcd pio sm
/// @param pio : PIO instance
/// @param sm : state machine number
/// @param x : need transmit data
static inline void vlcd_put32(PIO pio, uint sm, uint32_t x) 
{
    while (pio_sm_is_tx_fifo_full(pio, sm))
        ;
    *(volatile uint32_t*)&pio->txf[sm] = x;
}

/// @brief put a word(16-bit) to lcd pio sm
/// @param pio : PIO instance
/// @param sm : state machine number
/// @param x : need transmit data
static inline void vlcd_put16(PIO pio, uint sm, uint16_t x) 
{
    while (pio_sm_is_tx_fifo_full(pio, sm))
        ;
    *(volatile uint16_t*)&pio->txf[sm] = x;
}

/// @brief put a byte(8-bit) to lcd pio sm
/// @param pio : PIO instance
/// @param sm : state machine number
/// @param x : need transmit data
static inline void vlcd_put8(PIO pio, uint sm, uint8_t x) 
{
    while (pio_sm_is_tx_fifo_full(pio, sm))
        ;
    *(volatile uint8_t*)&pio->txf[sm] = x;
}

/// @brief Data stage regression, When the number of data bits sent is a multiple of 32
/// @param pio : PIO instance
/// @param sm : state machine number
static inline void vlcd_sm_return_when32DataBit(PIO pio, uint sm) 
{
    vlcd_put32(pio, sm, 0UL);
}

/// @brief lcd send a frame include: cmd and data
/// @param pio : PIO instance
/// @param sm : state machine number
/// @param cmd : lcd command
/// @param data : pointer of lcd needed data
/// @param bytes : bytes of all data
static inline void vlcd_put_cmdAnddata(PIO pio, uint sm, uint8_t cmd, const uint32_t * data, uint32_t bytes)
{
    /* 1. set cmd bits and cmd */
    vlcd_put32(pio, sm, (0x00000700 | (uint32_t)cmd));
    /* 2. set send data all bits */
    if(0 == bytes || NULL == data)
    {
        /* no cmd param(data), sm return start */
        vlcd_sm_return_when32DataBit(pio, sm);
        /* exit */
        return;
    }
    else
    {
        /* have param(data) */
        vlcd_put32(pio, sm, ((bytes * 8) - 1));
    }
    /* 3. send data */
    const uint8_t * puc = (const uint8_t *)data;
    int count = bytes / sizeof(uint32_t);
    int remain = bytes % sizeof(uint32_t);
    /* 32-bit send */
    if(0 != count)
    {
        for(int i = 0; i < count; i++)
        {
            /* put param(data) */
            vlcd_put32(pio, sm, *(uint32_t *)puc);
            /* step-by-step */
            puc += 4;
        }
    }
    /* based on whether 32-bit alignment processing is performed */
    /* non-aligned on 32-bit */
    if(0 != remain)
    {
        /* 4. handling the remaining bytes */
        /* 4.1 16-bit format first */
        if(remain >= 2)
        {
            /* put remaining 16-bit */
            vlcd_put16(pio, sm, *(uint16_t *)puc);  // ?????
            /* remaining bytes */
            remain -= 2;
            puc += 2;
        }
        /* 4.2 the last byte */
        if(0 != remain)
        {
            /* put remaining 8-bit */
            vlcd_put8(pio, sm, puc[0]);  // ?????
        }
        /* non-aligned autoregression */
    }
    /* aligned on 32-bit */
    else
    {
        /* 5. determine whether manual regression is required */
        /* sm return start */
        vlcd_sm_return_when32DataBit(pio, sm);
        /* exit */
        // return;
    }
}


// SM is done when it stalls on an empty FIFO


/// @brief wait lcd pio idle
/// @param pio : PIO instance
/// @param sm : state machine number
static inline void vlcd_wait_idle(PIO pio, uint sm) 
{
    uint32_t sm_stall_mask = 1u << (sm + PIO_FDEBUG_TXSTALL_LSB);
    pio->fdebug = sm_stall_mask;
    while (!(pio->fdebug & sm_stall_mask))
        ;
}

%}